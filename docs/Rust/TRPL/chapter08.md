# 8. Common Collections

## 8.1. Storing Lists of Values with Vectors

### Creating a New Vector

```rust
let v: Vec<i32> = Vec::new();
```

Rust conveniently provides the `vec!` macro, which will create a new vector that holds the values you give it.

```rust
let v = vec![1, 2, 3];
```

### Updating a Vector

```rust
let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
```

### Reading Elements of Vectors

There are two ways to reference a value stored in a vector: via indexing or by using the `get` method.

Using `&` and `[]` gives us a reference to the element at the index value. When we use the `get` method with the index passed as an argument, we get an `Option<&T>` that we can use with match.

```rust
let v = vec![1, 2, 3, 4, 5];

let third: &i32 = &v[2];
println!("The third element is {third}");

let third: Option<&i32> = v.get(2);
match third {
    Some(third) => println!("The third element is {third}"),
    None => println!("There is no third element."),
}
```

The `[]` method will cause the program to panic when it references a nonexistent element.

When the `get` method is passed an index that is outside the vector, it returns `None` without panicking.

### Iterating Over the Values in a Vector

Use a `for` loop to get immutable references to each element in a vector.

```rust
let v = vec![100, 32, 57];
for i in &v {
    println!("{i}");
}
```

We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements.

```rust
let mut v = vec![100, 32, 57];
for i in &mut v {
    *i += 50;
}
```

### Using an Enum to Store Multiple Types

```rust
enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from("blue")),
    SpreadsheetCell::Float(10.12),
];
```

### Dropping a Vector Drops Its Elements

Like any other struct, a vector is freed when it goes out of scope.

When the vector gets dropped, all of its contents are also dropped, meaning the integers it holds will be cleaned up.

```rust
{
    let v = vec![1, 2, 3, 4];

    // do stuff with v
} // <- v goes out of scope and is freed here
```

## 8.2. Storing UTF-8 Encoded Text with Strings

### Creating a New String

Many of the same operations available with `Vec<T>` are available with `String` as well because `String` is actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions, and capabilities.

```rust
let mut s = String::new();
```

We use the `to_string` method, which is available on any type that implements the `Display` trait, as string literals do.

```rust
let data = "initial contents";

let s = data.to_string();

// The method also works on a literal directly:
let s = "initial contents".to_string();
```

We can also use the function `String::from` to create a `String` from a string literal.

```rust
let s = String::from("initial contents");
```

### Appending to a String with push_str and push

We can grow a String by using the `push_str` method to append a string slice.

```rust
let mut s = String::from("foo");
s.push_str("bar");
```

The `push_str` method takes a string slice because we don't necessarily want to take ownership of the parameter.

```rust
let mut s1 = String::from("foo");
let s2 = "bar";
s1.push_str(s2);
println!("s2 is {s2}");
```

If the `push_str` method took ownership of `s2`, we wouldn't be able to print its value on the last line.

The `push` method takes a single character as a parameter and adds it to the `String`.

```rust
let mut s = String::from("lo");
s.push('l');
```

### Concatenation with the + Operator or the format! Macro

One way to combine two existing strings is to use the `+` operator:

```rust
let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
```

For combining strings in more complicated ways, we can instead use the `format!` macro:

```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = format!("{s1}-{s2}-{s3}");
```

The code generated by the `format!` macro uses references so that this call doesn't take ownership of any of its parameters.

### Indexing into Strings

```rust
let hello = "Здравствуйте";
// return the byte value, so answer will be 208, not 3
let answer = &hello[0];
```

### Slicing Strings

Here, `s` will be a `&str` that contains the first four bytes of the string.

```rust
let hello = "Здравствуйте";
// s will be Зд
let s = &hello[0..4];
```

### Methods for Iterating Over Strings

For individual Unicode scalar values, use the `chars` method.

```rust
for c in "Зд".chars() {
    println!("{c}");
}
```

Alternatively, the `bytes` method returns each raw byte.

```rust
for b in "Зд".bytes() {
    println!("{b}");
}
```

## 8.3. Storing Keys with Associated Values in Hash Maps

### Creating a New Hash Map

Just like vectors, hash maps store their data on the heap.

Like vectors, hash maps are homogeneous: all of the keys must have the same type, and all of the values must have the same type.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);
```

### Accessing Values in a Hash Map

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
```

The `get` method returns an `Option<&V>`; if there's no value for that key in the hash map, get will return `None`.

This program handles the `Option` by calling `copied` to get an `Option<i32>` rather than an `Option<&i32>`, then `unwrap_or` to set `score` to zero if `scores` doesn't have an entry for the key.

We can iterate over each key-value pair in a hash map using a `for` loop:

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Yellow"), 50);

for (key, value) in &scores {
    println!("{key}: {value}");
}
```

### Hash Maps and Ownership

For types that implement the `Copy` trait, like `i32`, the values are copied into the hash map. For owned values like `String`, the values will be moved and the hash map will be the owner of those values.

```rust
use std::collections::HashMap;

let field_name = String::from("Favorite color");
let field_value = String::from("Blue");

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
```

### Overwriting a Value

If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from("Blue"), 10);
scores.insert(String::from("Blue"), 25);

// 10 has been overwritten
println!("{scores:?}");
```

### Adding a Key and Value Only If a Key Isn’t Present

The return value of the `entry` method is an enum called `Entry` that represents a value that might or might not exist.

The `or_insert` method on `Entry` is defined to return a mutable reference to the value for the corresponding `Entry` key if that key exists.

```rust
use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);

scores.entry(String::from("Yellow")).or_insert(50);
scores.entry(String::from("Blue")).or_insert(50);

println!("{scores:?}");
```

### Updating a Value Based on the Old Value

Another common use case for hash maps is to look up a key's value and then update it based on the old value.

```rust
use std::collections::HashMap;

let text = "hello world wonderful world";

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!("{map:?}");
```

The `or_insert` method returns a mutable reference (`&mut V`) to the value for the specified key.

Here, we store that mutable reference in the `count` variable, so in order to assign to that value, we must first dereference `count` using the asterisk (`*`).
